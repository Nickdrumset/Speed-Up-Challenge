<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nick Drum – Speed Up Exercise (All-in-One)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&amp;display=swap" rel="stylesheet">
  <style>
    :root{
      --bg1:#bcd9cc; --bg2:#ffc49c; --bg3:#b9d0f3;
      --card:#f4f4f4ee; --text:#1b262f; --muted:#495762;
      --accent:#088ca3; --ok:#279854; --warn:#a86c14;
      --tile:#ebeff5; --tile-on:#dae3f1; --tile-border:#d9e0eb;
      --grid:#e3e9f3;
      --shadow:0 8px 28px rgba(0,0,0,.18), 0 2px 6px rgba(0,0,0,.08);
    }
    *{box-sizing:border-box}
    html,body{height:100%}

    body {
      margin: 0; min-height: 100%;
      background:
        radial-gradient(1200px 800px at 0% 0%, var(--bg1) 0%, transparent 60%),
        radial-gradient(1200px 800px at 100% 20%, var(--bg2) 0%, transparent 55%),
        radial-gradient(1000px 700px at 75% 100%, var(--bg3) 0%, transparent 60%),
        #f6f8fb;
      color: var(--text);
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      text-align: center;
      overflow: hidden; /* 스크롤 방지 */
    }

    .scale-viewport{ position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; padding: 10px; }
    #scale-content{ transform-origin: center center; will-change: transform; }

    .wrap{ max-width:1100px; margin:24px auto; padding:16px; }

    .hero{
      font-size: clamp(28px, 5.5vw, 64px); font-weight: 800; line-height: 1.05;
      margin: 4px 0 10px; color: transparent;
      -webkit-text-stroke: 2px rgba(255,255,255,0.85);
      text-shadow: 0 2px 4px rgba(0,0,0,0.25); letter-spacing: .5px;
    }
    
    .card{
      background: var(--card); border: 1px solid rgba(255,255,255,0.7);
      border-radius: 20px; box-shadow: var(--shadow);
      backdrop-filter: saturate(1.2) blur(4px);
    }

    /* Controls */
    .controls{ padding: 12px 24px; display: flex; justify-content: flex-start; gap: 24px; align-items: center; }
    .controls label{font-size:12px;color:var(--muted);font-weight:600;letter-spacing:.2px; margin-bottom: 4px;}
    .controls .grp{display:flex;flex-direction:column;align-items:flex-start;}
    
    /* Nav Buttons (탭 방식) */
    .nav-grp { display: flex; gap: 6px; padding-right: 24px; border-right: 1px solid #dce3ed; margin-right: 0; }
    .nav-btn {
      cursor: pointer; text-decoration: none; padding: 8px 14px;
      border-radius: 10px; font-size: 13px; font-weight: 700;
      color: var(--muted); background: rgba(255,255,255,0.5);
      border: 1px solid transparent; transition: all 0.2s ease;
      display: flex; flex-direction: column; align-items: center; line-height: 1.2;
      user-select: none;
    }
    .nav-btn span { font-size: 9px; opacity: 0.6; font-weight: 400; }
    .nav-btn:hover { background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.05); color: var(--text); }
    .nav-btn.active { background: #fff; color: var(--accent); border: 1px solid var(--accent); box-shadow: 0 2px 6px rgba(8, 140, 163, 0.15); }

    input[type=number]{
      background:#fff; border:1px solid var(--tile-border); color:var(--text);
      padding:8px 12px; border-radius:14px; font-size:16px;
      box-shadow:0 1px 0 rgba(0,0,0,.03) inset; height: 42px; width: 100px;
    }
    
    .btns{ display: flex; flex-direction: row; gap:10px; margin-left: auto; }
    button{cursor:pointer;border:1px solid #e7ebf2;background:#ffffff;color:var(--text);padding:10px 24px;border-radius:14px;font-weight:700;box-shadow:0 2px 0 rgba(0,0,0,.04); font-size: 15px;}
    button.primary{background:#f0fbff;border-color:#d4eef6; color: var(--accent);}
    button.warn{background:#fff6ea;border-color:#f3e2c7; color: var(--warn);}
    button:disabled{opacity:.5;cursor:not-allowed; filter: grayscale(1);}

    /* Grid & Slots */
    .grid{margin-top:16px;padding:20px;border-top:1px solid #eef2f7}
    .grid h3{margin:0 0 16px;font-size:16px;color:#3a4b5a}
    .slots{display:flex;flex-direction:column;gap:16px;align-items:center;justify-content:center}
    .bar{display:flex;gap:0px;margin-bottom:0}
    .measure { display: flex; gap: 0; margin-right: 12px; }
    .measure:last-child { margin-right: 0; }

    /* Slot Image Styles */
    .slot-img {
      background: var(--tile); border: 1px solid var(--tile-border); user-select: none;
    }
    /* Single Mode Size (72px) */
    .size-normal { width: 72px; height: 72px; }
    /* Double/Paradiddle Mode Size (100px) */
    .size-large { width: 100px; height: 100px; }

    .slot-img.playing{
      background: var(--tile-on); border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(14,165,183,.25); transition: none;
    }
    .measure img:first-child { border-top-left-radius: 8px; border-bottom-left-radius: 8px; }
    .measure img:last-child { border-top-right-radius: 8px; border-bottom-right-radius: 8px; }

    /* Mobile / Portrait */
    @media (max-aspect-ratio: 3/4) {
      .wrap { max-width: 100%; padding: 12px; }
      .controls {
        display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: auto auto auto;
        grid-template-areas: "nav nav" "bpm target" "btns btns"; gap: 12px; padding: 16px; justify-items: center;
      }
      .nav-grp { grid-area: nav; width: 100%; border:none; border-bottom: 1px solid #eef2f7; padding:0 0 12px 0; justify-content: center; }
      .nav-btn { flex: 1; display: block; text-align: center; }
      .nav-btn span { display: none; }
      .controls .grp:nth-child(2) { grid-area: bpm; }
      .controls .grp:nth-child(3) { grid-area: target; }
      .controls .grp.btns { grid-area: btns; width: 100%; justify-content: space-between; }
      .bar { flex-wrap: wrap; justify-content: center; gap: 8px; }
      .measure { margin-right: 0; }
      
      /* Mobile sizes */
      .size-normal { width: 17vw; height: 17vw; max-width: 85px; max-height: 85px; }
      .size-large { width: 20vw; height: 20vw; max-width: 100px; max-height: 100px; }
    }
  </style>
</head>
<body>
  <div class="scale-viewport">
    <div class="wrap" id="scale-content">
      <div class="hero">Speed Up Exercise</div>

      <section class="card controls">
        <nav class="nav-grp">
          <div class="nav-btn active" id="btn-single" onclick="setMode('single')">Single <span>(Q)</span></div>
          <div class="nav-btn" id="btn-double" onclick="setMode('double')">Double <span>(W)</span></div>
          <div class="nav-btn" id="btn-paradiddle" onclick="setMode('paradiddle')">Paradiddle <span>(E)</span></div>
        </nav>

        <div class="grp">
          <label for="bpm">Start BPM</label>
          <input id="bpm" type="number" min="30" max="240" step="5" value="80"/>
        </div>
        <div class="grp">
          <label for="target">Target BPM</label>
          <input id="target" type="number" min="40" max="300" step="5" value="200"/>
        </div>

        <div class="grp btns">
          <button id="start" class="primary">Start</button>
          <button id="stop" class="warn" disabled>Stop</button>
        </div>
      </section>

      <section class="card grid">
        <h3 id="mode-title">Pattern Slots</h3>
        <div class="slots" id="slots-container">
          </div>
      </section>
    </div>
  </div>

  <script>
    // ====== [설정] 모드별 데이터 정의 ======
    const CONFIG = {
      single: {
        title: "Pattern Slots (Single Stroke)",
        folder: "Images", // index.html 원본 폴더
        sizeClass: "size-normal", // 72px
        // Single 레이아웃 (2줄, 각 3마디) - index.html 내용 반영
        layout: [
          { measures: [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]] },
          { measures: [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]] }
        ],
        // 소리 패턴: index.html의 'oxox' (8분음표 느낌) 반복
        soundPatternGenerator: (totalBeats) => {
          const arr = [];
          // Single은 이미지 ID와 상관없이 고정된 'oxox' 패턴을 씀
          for(let i=0; i<totalBeats; i++) arr.push('oxox');
          return arr;
        }
      },
      double: {
        title: "Pattern Slots (Double Stroke)",
        folder: "Images2", // Double.html 원본 폴더
        sizeClass: "size-large", // 100px
        // Double 레이아웃 (3줄) - 요청하신 4,0,4,0... 패턴
        layout: [
          { measures: [[1, 0, 1, 0], [1, 0, 1, 0]] },
          { measures: [[1, 1, 0, 0], [1, 1, 0, 0]] },
          { measures: [[1, 1, 1, 1], [0, 0, 0, 0]] }
        ],
        // 소리 패턴: 4연음 vs 무음
        soundPatternGenerator: () => {
          const p4 = 'oooo'; const p0 = 'xxxx';
          return [
            p4, p0, p4, p0, p4, p0, p4, p0,
            p4, p4, p0, p0, p4, p4, p0, p0,
            p4, p4, p4, p4, p0, p0, p0, p0
          ];
        }
      },
      paradiddle: {
        title: "Pattern Slots (Paradiddle)",
        folder: "Images2", // Paradiddle.html 원본 폴더
        sizeClass: "size-large", // 100px
        // Paradiddle 레이아웃 (3줄) - 요청하신 2,0,3,0... 패턴
        layout: [
          { measures: [[2, 0, 3, 0], [2, 0, 3, 0]] },
          { measures: [[2, 3, 0, 0], [2, 3, 0, 0]] },
          { measures: [[2, 3, 2, 3], [0, 0, 0, 0]] }
        ],
        // 소리 패턴: 4연음 vs 무음
        soundPatternGenerator: () => {
          const p4 = 'oooo'; const p0 = 'xxxx';
          return [
            p4, p0, p4, p0, p4, p0, p4, p0,
            p4, p4, p0, p0, p4, p4, p0, p0,
            p4, p4, p4, p4, p0, p0, p0, p0
          ];
        }
      }
    };

    // ====== 전역 상태 변수 ======
    let currentMode = 'single'; // 기본 모드
    let isPlaying = false;
    let scheduledTimeouts = [];
    let currentHighlight = -1;
    let audioCtx = null;
    let slotImgs = []; // 현재 화면의 이미지 엘리먼트들

    // DOM 엘리먼트
    const elBpm = document.getElementById('bpm');
    const elTarget = document.getElementById('target');
    const elStart = document.getElementById('start');
    const elStop = document.getElementById('stop');
    const elTitle = document.getElementById('mode-title');
    const elSlotsContainer = document.getElementById('slots-container');

    // ====== 모드 전환 함수 (핵심) ======
    function setMode(modeName) {
      if (currentMode === modeName) return;
      
      // 1. 재생 중이면 정지
      if (isPlaying) stop();

      // 2. 모드 업데이트
      currentMode = modeName;

      // 3. 버튼 스타일 업데이트
      document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
      document.getElementById(`btn-${modeName}`).classList.add('active');

      // 4. 화면(그리드) 다시 그리기
      renderSlots();
    }

    // 화면 렌더링 함수
    function renderSlots() {
      const config = CONFIG[currentMode];
      elTitle.innerText = config.title;
      elSlotsContainer.innerHTML = ''; // 기존 내용 지우기

      // 레이아웃 설정에 따라 HTML 생성
      config.layout.forEach(row => {
        const divBar = document.createElement('div');
        divBar.className = 'bar';
        
        row.measures.forEach(measure => {
          const divMeasure = document.createElement('div');
          divMeasure.className = 'measure';
          
          measure.forEach(imgId => {
            const img = document.createElement('img');
            img.src = `${config.folder}/${imgId}.png`;
            img.alt = imgId;
            img.className = `slot-img ${config.sizeClass}`;
            divMeasure.appendChild(img);
          });
          
          divBar.appendChild(divMeasure);
        });
        
        elSlotsContainer.appendChild(divBar);
      });

      // 이미지 목록 캐싱 (애니메이션용)
      slotImgs = Array.from(document.querySelectorAll('.slot-img'));
      // 화면 크기 재조정
      fitScale(); 
    }

    // ====== 오디오 로직 ======
    const TEMPO_INCREMENT = 10;

    function initAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
      if (!window.masterGain) {
        window.masterGain = audioCtx.createGain();
        window.masterGain.connect(audioCtx.destination);
      }
      window.masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
      window.masterGain.gain.setValueAtTime(1, audioCtx.currentTime);
      return audioCtx;
    }

    function at(time, fn) {
      const delay = Math.max(0, (time - audioCtx.currentTime) * 1000);
      const id = setTimeout(fn, delay);
      scheduledTimeouts.push(id);
      return id;
    }

    // 카운트인 소리 (높은 톤)
    function claveSound(time, accent=false) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const hp = audioCtx.createBiquadFilter();
      const g = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(accent ? 2000 : 1700, time);
      hp.type = 'highpass'; hp.frequency.setValueAtTime(1200, time);
      g.gain.setValueAtTime(accent ? 0.34 : 0.26, time);
      g.gain.exponentialRampToValueAtTime(0.0001, time + 0.045);
      osc.connect(hp).connect(g).connect(window.masterGain);
      osc.start(time); osc.stop(time + 0.05);
    }

    // 스네어 드럼 소리
    function snareSound(time) {
      if (!audioCtx) return;
      const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.18, audioCtx.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < noiseBuffer.length; i++) data[i] = Math.random() * 2 - 1;
      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuffer;
      const hp = audioCtx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.setValueAtTime(1200, time);
      const bp = audioCtx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.setValueAtTime(2500, time); bp.Q.setValueAtTime(0.8, time);
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.6, time);
      g.gain.exponentialRampToValueAtTime(0.01, time + 0.12);
      noise.connect(hp).connect(bp).connect(g).connect(window.masterGain);
      noise.start(time); noise.stop(time + 0.18);
    }

    // 메트로놈 클릭 소리
    function clickSound(time, accent=false) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(accent ? 1500 : 1200, time);
      g.gain.setValueAtTime(accent ? 0.25 : 0.18, time);
      g.gain.exponentialRampToValueAtTime(0.0001, time + 0.04);
      osc.connect(g).connect(window.masterGain);
      osc.start(time); osc.stop(time + 0.05);
    }

    // 시각적 하이라이트
    function highlightBeatIndex(idx, startAt, durSec) {
      if(idx < 0 || idx >= slotImgs.length) return;
      at(startAt, ()=> {
        if(currentHighlight !== -1 && slotImgs[currentHighlight]){
          slotImgs[currentHighlight].classList.remove('playing');
        }
        currentHighlight = idx;
        slotImgs[idx].classList.add('playing');
      });
      at(startAt + durSec, ()=>{
        if(slotImgs[idx]) slotImgs[idx].classList.remove('playing');
        if(currentHighlight === idx) currentHighlight = -1;
      });
    }

    // 패턴 1회 재생
    function playPatternOnce(startAt, bpmCurrent, patternArr) {
      const secPerBeat = 60 / bpmCurrent;
      const barLen = 4; 
      
      for(let beatIdx = 0; beatIdx < patternArr.length; beatIdx++){
        const beatStr = patternArr[beatIdx]; // 'oooo' or 'xxxx'
        const beatStart = startAt + beatIdx * secPerBeat;
        
        // 1. 메트로놈 (항상 재생)
        clickSound(beatStart, (beatIdx % barLen) === 0);
        
        // 2. 시각적 표시
        highlightBeatIndex(beatIdx, beatStart, secPerBeat);
        
        // 3. 스네어 연주 (패턴에 'o'가 있을 때만)
        for(let sub = 0; sub < 4; sub++){
          if(beatStr[sub] === 'o') snareSound(beatStart + sub * (secPerBeat/4));
        }
      }
      return startAt + patternArr.length * secPerBeat;
    }

    // 반복 재생 로직 (속도 증가 포함)
    function playCycleChain(startAt, bpmCurrent, targetBpm, withCountIn=false) {
      if (!isPlaying) return;
      
      // 현재 모드에 맞는 소리 패턴 생성
      const currentConfig = CONFIG[currentMode];
      const totalSlots = slotImgs.length;
      const patternArr = currentConfig.soundPatternGenerator(totalSlots);

      let t = startAt;
      const secPerBeat = 60 / bpmCurrent;

      // 속도가 바뀔 때 카운트인(4박자)
      if (withCountIn) {
        for(let i=0; i<4; i++) claveSound(t + i * secPerBeat, i === 0);
        t += 4 * secPerBeat;
      }

      const endAt = playPatternOnce(t, bpmCurrent, patternArr);

      // 목표 BPM 도달 시 종료
      if (bpmCurrent >= targetBpm) {
        at(endAt + 0.05, () => stop());
        return;
      }

      // 다음 BPM 준비
      const nextBpm = Math.min(targetBpm, bpmCurrent + TEMPO_INCREMENT);
      const nextStart = Math.max(endAt + 0.02, audioCtx.currentTime + 0.02);

      at(nextStart, () => {
        elBpm.value = nextBpm;
        playCycleChain(nextStart, nextBpm, targetBpm, true);
      });
    }

    function start() {
      stop();
      initAudio();
      isPlaying = true;
      elStart.disabled = true;
      elStop.disabled = false;
      
      let curBpm = parseInt(elBpm.value || 80, 10);
      let tgtBpm = parseInt(elTarget.value || 200, 10);
      curBpm = Math.max(30, Math.min(240, curBpm));
      tgtBpm = Math.max(40, Math.min(300, tgtBpm));
      elBpm.value = curBpm;
      elTarget.value = tgtBpm;

      const secPerBeat = 60 / curBpm;
      const t0 = audioCtx.currentTime + 0.1;

      // 시작 전 예비박 (4박자)
      for(let i=0; i<4; i++) claveSound(t0 + i * secPerBeat, i === 0);
      
      const firstPatternStart = t0 + 4 * secPerBeat;
      at(firstPatternStart - 0.01, () => playCycleChain(firstPatternStart, curBpm, tgtBpm, false));
    }

    function stop() {
      isPlaying = false;
      scheduledTimeouts.forEach(id => clearTimeout(id));
      scheduledTimeouts = [];
      if(currentHighlight !== -1 && slotImgs[currentHighlight]){
        slotImgs[currentHighlight].classList.remove('playing');
        currentHighlight = -1;
      }
      elStart.disabled = false;
      elStop.disabled = true;
      if (audioCtx) {
        if(window.masterGain) {
            try { window.masterGain.disconnect(); } catch(e){}
            window.masterGain = null; 
        }
      }
    }

    // 화면 크기 자동 조절
    function fitScale(){
      const content = document.getElementById('scale-content');
      if(!content) return;
      content.style.transform = 'none';
      const rect = content.getBoundingClientRect();
      const vpW = Math.max(1, window.innerWidth - 20);
      const vpH = Math.max(1, window.innerHeight - 20);
      const scale = Math.min(vpW / rect.width, vpH / rect.height);
      content.style.transform = `scale(${scale})`;
    }
    window.addEventListener('resize', fitScale);
    window.addEventListener('orientationchange', fitScale);
    
    // 초기화
    renderSlots(); // 처음에는 Single 모드로 렌더링
    fitScale();

    // 이벤트 리스너
    elStart.addEventListener('click', start);
    elStop.addEventListener('click', stop);

    // 키보드 단축키
    window.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT') return;
      const key = e.key.toLowerCase();
      
      if (key === ' ' || e.code === 'Space') {
        e.preventDefault(); isPlaying ? stop() : start();
      } 
      else if (key === 'f') {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else document.exitFullscreen();
      }
      else if (e.key === 'ArrowUp') {
        e.preventDefault();
        let val = parseInt(elBpm.value || 80, 10);
        elBpm.value = Math.min(240, val + 10);
      }
      else if (e.key === 'ArrowDown') {
        e.preventDefault();
        let val = parseInt(elBpm.value || 80, 10);
        elBpm.value = Math.max(30, val - 10);
      }
      else if (key === 'q') setMode('single');
      else if (key === 'w') setMode('double');
      else if (key === 'e') setMode('paradiddle');
    });
  </script>
</body>
</html>
